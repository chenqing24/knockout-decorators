{"version":3,"file":"knockout-decorators.min.js","sources":["../src/common-functions.ts","../src/property-extenders.ts","../src/observable-property.ts","../src/observable-array.ts","../src/knockout-decorators.ts","../src/event-property.ts"],"sourcesContent":["/**\r\n * Copyright (c) 2016-2018 Dmitry Panyushkin\r\n * Available under MIT license\r\n */\r\nimport * as ko from \"knockout\";\r\n\r\nconst prefix = \"__ko_decorators_\";\r\n\r\nexport let PATCHED_KEY: string | symbol = prefix + \"patched__\";\r\nexport let EXTENDERS_KEY: string | symbol = prefix + \"extenders__\";\r\nexport let SUBSCRIPTIONS_KEY: string | symbol = prefix + \"subscriptions__\";\r\n\r\nif (typeof Symbol !== \"undefined\") {\r\n  PATCHED_KEY = Symbol(PATCHED_KEY);\r\n  EXTENDERS_KEY = Symbol(EXTENDERS_KEY);\r\n  SUBSCRIPTIONS_KEY = Symbol(SUBSCRIPTIONS_KEY);\r\n}\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const ArrayPrototype = Array.prototype;\r\n\r\nexport function defineProperty(instance: Object, key: any, descriptor: PropertyDescriptor) {\r\n  descriptor.configurable = true;\r\n  Object.defineProperty(instance, key, descriptor);\r\n}\r\n\r\nexport const extendObject = ko.utils.extend;\r\nexport const objectForEach = ko.utils.objectForEach;\r\nexport const isArray = Array.isArray.bind(Array);\r\nexport const getPrototypeOf = Object.getPrototypeOf.bind(Object);\r\nexport const getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor.bind(Object);\r\nexport const hasOwnProperty = Function.prototype.call.bind(Object.prototype.hasOwnProperty);\r\nexport const arraySlice = Function.prototype.call.bind(ArrayPrototype.slice);\r\n","/**\r\n * Copyright (c) 2016-2018 Dmitry Panyushkin\r\n * Available under MIT license\r\n */\r\nimport { EXTENDERS_KEY, extendObject, hasOwnProperty, objectForEach } from \"./common-functions\";\r\n\r\ntype Extender = Object | Function;\r\n\r\ninterface ExtendersDictionary {\r\n  [propName: string]: Extender[];\r\n}\r\n\r\nexport function applyExtenders(\r\n  instance: Object, key: string | symbol,\r\n  target: ko.Observable<any> | ko.Computed<any>,\r\n) {\r\n  const dictionary = instance[EXTENDERS_KEY] as ExtendersDictionary;\r\n  const extenders = dictionary && dictionary[key as any];\r\n  if (extenders) {\r\n    extenders.forEach((extender) => {\r\n      const koExtender = extender instanceof Function\r\n        ? extender.call(instance) : extender;\r\n\r\n      target = target.extend(koExtender);\r\n    });\r\n  }\r\n  return target;\r\n}\r\n\r\nexport function defineExtenders(\r\n  prototype: Object, key: string | symbol,\r\n  extendersOrFactory: Object | Function,\r\n) {\r\n  let dictionary = prototype[EXTENDERS_KEY] as ExtendersDictionary;\r\n  // if there is no ExtendersDictionary or ExtendersDictionary lives in base class prototype\r\n  if (!hasOwnProperty(prototype, EXTENDERS_KEY)) {\r\n    // clone ExtendersDictionary from base class prototype or create new ExtendersDictionary\r\n    prototype[EXTENDERS_KEY] = dictionary = extendObject({}, dictionary) as ExtendersDictionary;\r\n    // clone Extenders arrays for each property key\r\n    objectForEach(dictionary, (existingKey, extenders) => {\r\n      dictionary[existingKey] = [...extenders];\r\n    });\r\n  }\r\n  // get existing Extenders array or create new array\r\n  const currentExtenders = dictionary[key as any] || (dictionary[key as any] = []);\r\n  // add new Extenders\r\n  currentExtenders.push(extendersOrFactory);\r\n}\r\n","/**\r\n * Copyright (c) 2016-2018 Dmitry Panyushkin\r\n * Available under MIT license\r\n */\r\nimport * as ko from \"knockout\";\r\nimport {\r\n  defineProperty, getPrototypeOf, hasOwnProperty, isArray, objectForEach, PATCHED_KEY,\r\n} from \"./common-functions\";\r\nimport { defineObservableArray } from \"./observable-array\";\r\nimport { applyExtenders } from \"./property-extenders\";\r\n\r\nexport function defineObservableProperty(\r\n  instance: Object, key: string | symbol, value: any, deep: boolean, expose: boolean,\r\n) {\r\n  const observable = applyExtenders(instance, key, ko.observable());\r\n\r\n  let setter = observable as any;\r\n\r\n  if (deep) {\r\n    setter = function (newValue: any) {\r\n      observable(prepareDeepValue(newValue, expose));\r\n    };\r\n  }\r\n\r\n  defineProperty(instance, key, {\r\n    enumerable: true,\r\n    get: observable,\r\n    set: setter,\r\n  });\r\n  if (expose) {\r\n    defineProperty(instance, \"_\" + String(key), {\r\n      value: observable,\r\n    });\r\n  }\r\n\r\n  setter(value);\r\n}\r\n\r\nexport function prepareDeepValue(value: any, expose: boolean) {\r\n  if (typeof value === \"object\") {\r\n    if (isArray(value) || value === null) {\r\n      // value is Array or null\r\n      return value;\r\n    } else if (hasOwnProperty(value, \"constructor\")) {\r\n      // there is redefined own property \"constructor\"\r\n      const prototype = getPrototypeOf(value);\r\n      if (prototype === Object.prototype || prototype === null) {\r\n        // value is plain Object\r\n        return prepareDeepObject(value, expose);\r\n      }\r\n    } else if (value.constructor === Object) {\r\n      // value is plain Object\r\n      return prepareDeepObject(value, expose);\r\n    }\r\n  }\r\n  // value is primitive, function or class instance\r\n  return value;\r\n}\r\n\r\nexport function prepareDeepObject(instance: Object, expose: boolean) {\r\n  if (!hasOwnProperty(instance, PATCHED_KEY)) {\r\n    // mark instance as ObservableObject\r\n    defineProperty(instance, PATCHED_KEY, {\r\n      value: true,\r\n    });\r\n    // define deep observable properties\r\n    objectForEach(instance, (key, value) => {\r\n      if (isArray(value)) {\r\n        defineObservableArray(instance, key, value, true, expose);\r\n      } else {\r\n        defineObservableProperty(instance, key, value, true, expose);\r\n      }\r\n    });\r\n  }\r\n  return instance;\r\n}\r\n","/**\r\n * Copyright (c) 2016-2018 Dmitry Panyushkin\r\n * Available under MIT license\r\n */\r\nimport * as ko from \"knockout\";\r\nimport { ArrayPrototype, arraySlice, defineProperty, hasOwnProperty, isArray, PATCHED_KEY } from \"./common-functions\";\r\nimport { prepareDeepValue } from \"./observable-property\";\r\nimport { applyExtenders } from \"./property-extenders\";\r\n\r\ntype ObsArray = ko.ObservableArray<any> & { [fnName: string]: Function };\r\n\r\nconst deepArrayMethods = [\"pop\", \"reverse\", \"shift\", \"sort\"];\r\nconst allArrayMethods = [...deepArrayMethods, \"push\", \"splice\", \"unshift\"];\r\n\r\nconst deepObservableArrayMethods = [\"remove\", \"removeAll\", \"destroy\", \"destroyAll\", \"replace\", \"subscribe\"];\r\nconst allObservableArrayMethods = [...deepObservableArrayMethods, \"replace\"];\r\n\r\nconst allMethods = [...allArrayMethods, ...allObservableArrayMethods, \"mutate\", \"set\"];\r\n\r\nexport function defineObservableArray(\r\n  instance: Object, key: string | symbol, value: any[], deep: boolean, expose: boolean,\r\n) {\r\n  const obsArray = applyExtenders(instance, key, ko.observableArray()) as ObsArray;\r\n\r\n  let insideObsArray = false;\r\n\r\n  defineProperty(instance, key, {\r\n    enumerable: true,\r\n    get: obsArray,\r\n    set: setter,\r\n  });\r\n  if (expose) {\r\n    defineProperty(instance, \"_\" + String(key), {\r\n      value: obsArray,\r\n    });\r\n  }\r\n\r\n  setter(value);\r\n\r\n  function setter(newValue: any[]) {\r\n    const lastValue = obsArray.peek();\r\n    // if we got new value\r\n    if (lastValue !== newValue) {\r\n      if (isArray(lastValue)) {\r\n        // if lastValue array methods were already patched\r\n        if (hasOwnProperty(lastValue, PATCHED_KEY)) {\r\n          delete lastValue[PATCHED_KEY];\r\n          // clear patched array methods on lastValue (see unit tests)\r\n          allMethods.forEach((fnName) => {\r\n            delete lastValue[fnName];\r\n          });\r\n        }\r\n      }\r\n      if (isArray(newValue)) {\r\n        // if new value array methods were already connected with another @observable\r\n        if (hasOwnProperty(newValue, PATCHED_KEY)) {\r\n          // clone new value to prevent corruption of another @observable (see unit tests)\r\n          newValue = [...newValue];\r\n        }\r\n        // if deep option is set\r\n        if (deep) {\r\n          // make all array items deep observable\r\n          for (let i = 0; i < newValue.length; ++i) {\r\n            newValue[i] = prepareDeepValue(newValue[i], expose);\r\n          }\r\n        }\r\n        // mark instance as ObservableArray\r\n        defineProperty(newValue, PATCHED_KEY, {\r\n          value: true,\r\n        });\r\n        // call ko.observableArray.fn[fnName] instead of Array.prototype[fnName]\r\n        patchArrayMethods(newValue);\r\n      }\r\n    }\r\n    // update obsArray contents\r\n    insideObsArray = true;\r\n    obsArray(newValue);\r\n    insideObsArray = false;\r\n  }\r\n\r\n  function patchArrayMethods(array: any[]) {\r\n    const arrayMethods = deep ? deepArrayMethods : allArrayMethods;\r\n\r\n    arrayMethods.forEach((fnName) => defineProperty(array, fnName, {\r\n      value() {\r\n        if (insideObsArray) {\r\n          return ArrayPrototype[fnName].apply(array, arguments);\r\n        }\r\n        insideObsArray = true;\r\n        const result = obsArray[fnName].apply(obsArray, arguments);\r\n        insideObsArray = false;\r\n        return result;\r\n      },\r\n    }));\r\n\r\n    const observableArrayMethods = deep ? deepObservableArrayMethods : allObservableArrayMethods;\r\n\r\n    observableArrayMethods.forEach((fnName) => defineProperty(array, fnName, {\r\n      value() {\r\n        insideObsArray = true;\r\n        const result = obsArray[fnName].apply(obsArray, arguments);\r\n        insideObsArray = false;\r\n        return result;\r\n      },\r\n    }));\r\n\r\n    if (deep) {\r\n      defineProperty(array, \"push\", {\r\n        value() {\r\n          if (insideObsArray) {\r\n            return ArrayPrototype.push.apply(array, arguments);\r\n          }\r\n          const args = arraySlice(arguments);\r\n          for (let i = 0; i < args.length; ++i) {\r\n            args[i] = prepareDeepValue(args[i], expose);\r\n          }\r\n          insideObsArray = true;\r\n          const result = obsArray.push.apply(obsArray, args);\r\n          insideObsArray = false;\r\n          return result;\r\n        },\r\n      });\r\n\r\n      defineProperty(array, \"unshift\", {\r\n        value() {\r\n          if (insideObsArray) {\r\n            return ArrayPrototype.unshift.apply(array, arguments);\r\n          }\r\n          const args = arraySlice(arguments);\r\n          for (let i = 0; i < args.length; ++i) {\r\n            args[i] = prepareDeepValue(args[i], expose);\r\n          }\r\n          insideObsArray = true;\r\n          const result = obsArray.unshift.apply(obsArray, args);\r\n          insideObsArray = false;\r\n          return result;\r\n        },\r\n      });\r\n\r\n      defineProperty(array, \"splice\", {\r\n        value() {\r\n          if (insideObsArray) {\r\n            return ArrayPrototype.splice.apply(array, arguments);\r\n          }\r\n\r\n          let result: any[];\r\n\r\n          insideObsArray = true;\r\n          switch (arguments.length) {\r\n            case 0:\r\n            case 1:\r\n            case 2: {\r\n              result = obsArray.splice.apply(obsArray, arguments);\r\n              break;\r\n            }\r\n            case 3: {\r\n              result = obsArray.splice(\r\n                arguments[0], arguments[1], prepareDeepValue(arguments[2], expose),\r\n              );\r\n              break;\r\n            }\r\n            default: {\r\n              const args = arraySlice(arguments);\r\n              for (let i = 2; i < args.length; ++i) {\r\n                args[i] = prepareDeepValue(args[i], expose);\r\n              }\r\n              result = obsArray.splice.apply(obsArray, arguments);\r\n              break;\r\n            }\r\n          }\r\n          insideObsArray = false;\r\n\r\n          return result;\r\n        },\r\n      });\r\n\r\n      defineProperty(array, \"replace\", {\r\n        value(oldItem: any, newItem: any) {\r\n          insideObsArray = true;\r\n          const result = obsArray.replace(oldItem, prepareDeepValue(newItem, expose));\r\n          insideObsArray = false;\r\n          return result;\r\n        },\r\n      });\r\n\r\n      defineProperty(array, \"mutate\", {\r\n        value(mutator: (array?: any[]) => void) {\r\n          const nativeArray = obsArray.peek();\r\n          // it is defined for ko.observableArray\r\n          (obsArray.valueWillMutate as Function)();\r\n          mutator(nativeArray);\r\n          for (let i = 0; i < nativeArray.length; ++i) {\r\n            nativeArray[i] = prepareDeepValue(nativeArray[i], expose);\r\n          }\r\n          // it is defined for ko.observableArray\r\n          (obsArray.valueHasMutated as Function)();\r\n        },\r\n      });\r\n\r\n      defineProperty(array, \"set\", {\r\n        value(index: number, newItem: any) {\r\n          return obsArray.splice(index, 1, prepareDeepValue(newItem, expose))[0];\r\n        },\r\n      });\r\n    } else {\r\n      defineProperty(array, \"mutate\", {\r\n        value(mutator: (array?: any[]) => void) {\r\n          // it is defined for ko.observableArray\r\n          (obsArray.valueWillMutate as Function)();\r\n          mutator(obsArray.peek());\r\n          // it is defined for ko.observableArray\r\n          (obsArray.valueHasMutated as Function)();\r\n        },\r\n      });\r\n\r\n      defineProperty(array, \"set\", {\r\n        value(index: number, newItem: any) {\r\n          return obsArray.splice(index, 1, newItem)[0];\r\n        },\r\n      });\r\n    }\r\n  }\r\n}\r\n","/**\r\n * Copyright (c) 2016-2018 Dmitry Panyushkin\r\n * Available under MIT license\r\n * Version: 2.0.0\r\n */\r\nimport * as ko from \"knockout\";\r\nimport {\r\n  defineProperty, extendObject, getOwnPropertyDescriptor, hasOwnProperty, isArray, PATCHED_KEY, SUBSCRIPTIONS_KEY,\r\n} from \"./common-functions\";\r\nimport { defineEventProperty } from \"./event-property\";\r\nimport { defineObservableArray } from \"./observable-array\";\r\nimport { defineObservableProperty } from \"./observable-property\";\r\nimport { applyExtenders, defineExtenders } from \"./property-extenders\";\r\n\r\n/**\r\n * Property decorator that creates hidden (shallow or deep) ko.observable with ES6 getter and setter for it\r\n * If initialized by Array then hidden ko.observableArray will be created\r\n */\r\nexport function observable(options: { deep?: boolean, expose?: boolean }): PropertyDecorator;\r\n/**\r\n * Property decorator that creates hidden (shallow) ko.observable with ES6 getter and setter for it\r\n * If initialized by Array then hidden (shallow) ko.observableArray will be created\r\n */\r\nexport function observable(prototype: Object, key: string | symbol): void;\r\n/**\r\n * Property decorator that creates hidden (shallow or deep) ko.observable with ES6 getter and setter for it\r\n * If initialized by Array then hidden (shallow or deep) ko.observableArray will be created\r\n */\r\nexport function observable(prototypeOrOptions: any, key?: any) {\r\n  observableArrayOption = false;\r\n  deepObservableOption = false;\r\n  exposeObservableOption = false;\r\n  if (arguments.length === 1) {\r\n    deepObservableOption = prototypeOrOptions.deep;\r\n    exposeObservableOption = prototypeOrOptions.expose;\r\n    return observableDecorator;\r\n  }\r\n  return observableDecorator(prototypeOrOptions, key);\r\n}\r\n\r\n/**\r\n * Property decorator that creates hidden (shallow or deep) ko.observableArray with ES6 getter and setter for it\r\n */\r\nexport function observableArray(options: { deep?: boolean, expose?: boolean }): PropertyDecorator;\r\n/**\r\n * Property decorator that creates hidden (shallow) ko.observableArray with ES6 getter and setter for it\r\n */\r\nexport function observableArray(prototype: Object, key: string | symbol): void;\r\n/**\r\n * Property decorator that creates hidden (shallow or deep) ko.observableArray with ES6 getter and setter for it\r\n */\r\nexport function observableArray(prototypeOrOptions: any, key?: any) {\r\n  observableArrayOption = true;\r\n  deepObservableOption = false;\r\n  exposeObservableOption = false;\r\n  if (arguments.length === 1) {\r\n    deepObservableOption = prototypeOrOptions.deep;\r\n    exposeObservableOption = prototypeOrOptions.expose;\r\n    return observableDecorator;\r\n  }\r\n  return observableDecorator(prototypeOrOptions, key);\r\n}\r\n\r\n// observableDecorator options\r\nlet observableArrayOption: boolean;\r\nlet deepObservableOption: boolean;\r\nlet exposeObservableOption: boolean;\r\n\r\nfunction observableDecorator(prototype: Object, propKey: string | symbol) {\r\n  const array = observableArrayOption;\r\n  const deep = deepObservableOption;\r\n  const expose = exposeObservableOption;\r\n  defineProperty(prototype, propKey, {\r\n    get() {\r\n      throw new Error(\"@observable property '\" + String(propKey) + \"' was not initialized\");\r\n    },\r\n    set(this: Object, value: any) {\r\n      if (array || isArray(value)) {\r\n        defineObservableArray(this, propKey, value, deep, expose);\r\n      } else {\r\n        defineObservableProperty(this, propKey, value, deep, expose);\r\n      }\r\n    },\r\n  });\r\n}\r\n\r\nexport interface ObservableArray<T> extends Array<T> {\r\n  replace(oldItem: T, newItem: T): void;\r\n\r\n  remove(item: T): T[];\r\n  remove(removeFunction: (item: T) => boolean): T[];\r\n\r\n  removeAll(): T[];\r\n  removeAll(items: T[]): T[];\r\n\r\n  destroy(item: T): void;\r\n  destroy(destroyFunction: (item: T) => boolean): void;\r\n\r\n  destroyAll(): void;\r\n  destroyAll(items: T[]): void;\r\n\r\n  subscribe(callback: (val: T[]) => void): ko.Subscription;\r\n  subscribe(callback: (val: T[]) => void, callbackTarget: any): ko.Subscription;\r\n  subscribe(callback: (val: any[]) => void, callbackTarget: any, event: string): ko.Subscription;\r\n\r\n  /**\r\n   * Run mutator function that can write to array at some index (`array[index] = value;`)\r\n   * Then notify about observableArray changes\r\n   */\r\n  mutate(mutator: (arrayValue: T[]) => void): void;\r\n\r\n  /**\r\n   * Replace value at some index and return old value\r\n   */\r\n  set(index: number, value: T): T;\r\n}\r\n\r\n/*---------------------------------------------------------------------------*/\r\n\r\n/**\r\n * Accessor decorator that wraps ES6 getter to hidden ko.computed or ko.pureComputed\r\n *\r\n * Setter is not wrapped to hidden ko.pureComputed and stays unchanged\r\n *\r\n * But we can still extend getter @computed by extenders like { rateLimit: 500 }\r\n */\r\nexport function computed(options: { pure: boolean }): PropertyDecorator;\r\n/**\r\n * Accessor decorator that wraps ES6 getter to hidden ko.pureComputed\r\n *\r\n * Setter is not wrapped to hidden ko.pureComputed and stays unchanged\r\n *\r\n * But we can still extend getter @computed by extenders like { rateLimit: 500 }\r\n */\r\nexport function computed(prototype: Object, key: string | symbol, desc?: PropertyDescriptor): PropertyDescriptor;\r\n/**\r\n * Accessor decorator that wraps ES6 getter to hidden ko.computed or ko.pureComputed\r\n *\r\n * Setter is not wrapped to hidden ko.pureComputed and stays unchanged\r\n *\r\n * But we can still extend getter @computed by extenders like { rateLimit: 500 }\r\n */\r\nexport function computed(prototypeOrOptinos: any, key?: any, propDesc?: any): any {\r\n  computedDecoratorOptions = { pure: true };\r\n\r\n  if (arguments.length === 1) {\r\n    computedDecoratorOptions = prototypeOrOptinos;\r\n    return computedDecorator;\r\n  }\r\n  return computedDecorator(prototypeOrOptinos, key, propDesc);\r\n}\r\n\r\n// computedDecorator options\r\nlet computedDecoratorOptions: { pure: boolean };\r\n\r\nfunction computedDecorator(prototype: Object, propKey: string | symbol, desc: PropertyDescriptor) {\r\n  const options = computedDecoratorOptions;\r\n  const { get, set } = desc || (desc = getOwnPropertyDescriptor(prototype, propKey));\r\n  if (!get) {\r\n    throw new Error(\"@computed property '\" + String(propKey) + \"' has no getter\");\r\n  }\r\n  desc.get = function (this: Object) {\r\n    const koComputed = applyExtenders(this, propKey, ko.computed(get, this, options));\r\n    defineProperty(this, propKey, {\r\n      get: koComputed,\r\n      // tslint:disable-next-line:object-literal-shorthand\r\n      set: set,\r\n    });\r\n    return koComputed();\r\n  };\r\n  return desc;\r\n}\r\n\r\n/*---------------------------------------------------------------------------*/\r\n\r\n/**\r\n * Apply extenders to decorated @observable\r\n */\r\nexport function extend(extenders: Object): PropertyDecorator;\r\n/**\r\n * Apply extenders to decorated @observable\r\n */\r\nexport function extend(extendersFactory: () => Object): PropertyDecorator;\r\n/**\r\n * Apply extenders to decorated @observable\r\n * @extendersOrFactory { Object | Function } Knockout extenders definition or factory that produces definition\r\n */\r\nexport function extend(extendersOrFactory: Object | Function) {\r\n  return function (prototype: Object, key: string | symbol) {\r\n    defineExtenders(prototype, key, extendersOrFactory);\r\n  };\r\n}\r\n\r\n/*---------------------------------------------------------------------------*/\r\n\r\nexport type ComponentConstructor = new (\r\n  params?: any,\r\n  element?: Node,\r\n  templateNodes?: Node[],\r\n) => any;\r\n\r\nexport type ComponentDecorator = (constructor: ComponentConstructor) => void;\r\n\r\nexport type TemplateConfig = (\r\n  string\r\n  | Node[]\r\n  | DocumentFragment\r\n  | { require: string }\r\n  | { element: string | Node }\r\n);\r\n\r\n/**\r\n * Register Knockout component by decorating ViewModel class\r\n */\r\nexport function component(\r\n  name: string,\r\n  options?: Object,\r\n): ComponentDecorator;\r\n/**\r\n * Register Knockout component by decorating ViewModel class\r\n */\r\nexport function component(\r\n  name: string,\r\n  template: TemplateConfig,\r\n  options?: Object,\r\n): ComponentDecorator;\r\n/**\r\n * Register Knockout component by decorating ViewModel class\r\n */\r\nexport function component(\r\n  name: string,\r\n  template: TemplateConfig,\r\n  styles: string | string[],\r\n  options?: Object,\r\n): ComponentDecorator;\r\n/**\r\n * Register Knockout component by decorating ViewModel class\r\n * @param name {String} Name of component\r\n * @param template {Any} Knockout template definition\r\n * @param styles {Any} Ignored parameter (used for `require()` styles by webpack etc.)\r\n * @param options {Object} Another options that passed directly to `ko.components.register()`\r\n */\r\nexport function component(\r\n  name: string,\r\n  template?: any,\r\n  styles?: any,\r\n  options?: Object,\r\n) {\r\n  if (options === void 0) {\r\n    if (styles === void 0) {\r\n      if (typeof template === \"object\"\r\n        && template.constructor === Object\r\n        && !(\"require\" in template)\r\n        && !(\"element\" in template)\r\n      ) {\r\n        options = template;\r\n        template = void 0;\r\n      }\r\n    } else if (typeof styles === \"object\") {\r\n      options = styles;\r\n      styles = void 0;\r\n    }\r\n  }\r\n\r\n  return function (constructor: ComponentConstructor) {\r\n    ko.components.register(name, extendObject({\r\n      viewModel: constructor.length < 2 ? constructor : {\r\n        createViewModel(params: any, {\r\n          element, templateNodes,\r\n        }: {\r\n            element: Node, templateNodes: Node[],\r\n          }) {\r\n          return new constructor(params, element, templateNodes);\r\n        },\r\n      },\r\n      template: template || \"<!---->\",\r\n      synchronous: true,\r\n    }, options as Object));\r\n  };\r\n}\r\n\r\n/*---------------------------------------------------------------------------*/\r\n\r\n/**\r\n * Like https://github.com/jayphelps/core-decorators.js @autobind but less smart and complex\r\n * Do NOT use with ES6 inheritance!\r\n */\r\nexport function autobind(prototype: Object, key: string | symbol, desc?: PropertyDescriptor) {\r\n  const { value, configurable, enumerable } = desc || (desc = getOwnPropertyDescriptor(prototype, key));\r\n  return {\r\n    // tslint:disable-next-line:object-literal-shorthand\r\n    configurable: configurable,\r\n    // tslint:disable-next-line:object-literal-shorthand\r\n    enumerable: enumerable,\r\n    get(this: Object) {\r\n      if (this === prototype) {\r\n        return value;\r\n      }\r\n      const bound = value.bind(this);\r\n      defineProperty(this, key, {\r\n        value: bound,\r\n      });\r\n      return bound;\r\n    },\r\n  } as PropertyDescriptor;\r\n}\r\n\r\n/*---------------------------------------------------------------------------*/\r\n\r\n/**\r\n * Define hidden ko.subscribable, that notifies subscribers when decorated method is invoked\r\n */\r\nexport function event(prototype: Object, key: string | symbol) {\r\n  defineProperty(prototype, key, {\r\n    get(this: Object) {\r\n      return defineEventProperty(this, key);\r\n    },\r\n  });\r\n}\r\n\r\nexport type EventType = Function & {\r\n  subscribe(callback: Function): ko.Subscription;\r\n};\r\n\r\n/*---------------------------------------------------------------------------*/\r\n\r\n/**\r\n * Subscribe callback to `@observable` or `@computed` dependency changes or to some `@event` property\r\n */\r\nexport function subscribe<T>(\r\n  dependencyOrEvent: () => T,\r\n  callback: (value: T) => void,\r\n  options?: { once?: boolean, event?: \"change\" | \"beforeChange\" },\r\n): ko.Subscription;\r\n/**\r\n * Subscribe callback to `@observableArray` dependency \"arrayChange\" event\r\n */\r\nexport function subscribe<T>(\r\n  dependency: () => T[],\r\n  callback: (value: {\r\n    status: \"added\" | \"deleted\";\r\n    value: T;\r\n    index: number;\r\n  }[]) => void,\r\n  options: { once?: boolean, event: \"arrayChange\" },\r\n): ko.Subscription;\r\n/**\r\n * Subscribe callback to some `@event` property\r\n */\r\nexport function subscribe<T>(\r\n  event: (arg: T) => void,\r\n  callback: (arg: T) => void,\r\n  options?: { once?: boolean },\r\n): ko.Subscription;\r\n/**\r\n * Subscribe callback to some `@event` property\r\n */\r\nexport function subscribe<T1, T2>(\r\n  event: (arg1: T1, arg2: T2) => void,\r\n  callback: (arg1: T1, arg2: T2) => void,\r\n  options?: { once?: boolean },\r\n): ko.Subscription;\r\n/**\r\n * Subscribe callback to some `@event` property\r\n */\r\nexport function subscribe<T1, T2, T3>(\r\n  event: (arg1: T1, arg2: T2, arg3: T3, ...args: any[]) => void,\r\n  callback: (arg1: T1, arg2: T2, arg3: T3, ...args: any[]) => void,\r\n  options?: { once?: boolean },\r\n): ko.Subscription;\r\n/**\r\n * Subscribe callback to `@observable` or `@computed` dependency changes or to some `@event`\r\n */\r\nexport function subscribe(\r\n  dependencyOrEvent: Function,\r\n  callback: (...args: any[]) => void,\r\n  options?: { once?: boolean, event?: \"change\" | \"beforeChange\" | \"arrayChange\" },\r\n) {\r\n  const once = options && options.once || false;\r\n\r\n  if (hasOwnProperty(dependencyOrEvent, \"subscribe\")) {\r\n    // overload: subscribe to @event property\r\n    const eventFunc = dependencyOrEvent as EventType;\r\n\r\n    if (once) {\r\n      const subscription = eventFunc.subscribe(function () {\r\n        subscription.dispose();\r\n        callback.apply(null, arguments);\r\n      });\r\n      return subscription;\r\n    } else {\r\n      return eventFunc.subscribe(callback);\r\n    }\r\n  } else {\r\n    // overload: subscribe to @observable or @computed\r\n    const eventFunc = options && options.event || \"change\";\r\n\r\n    let handler: (value: any) => void;\r\n    let subscription: ko.Subscription;\r\n\r\n    if (once) {\r\n      handler = function () {\r\n        subscription.dispose();\r\n        callback.apply(null, arguments);\r\n      };\r\n    } else {\r\n      handler = callback;\r\n    }\r\n\r\n    if (eventFunc === \"arrayChange\") {\r\n      const obsArray = dependencyOrEvent() as ObservableArray<any>;\r\n\r\n      if (isArray(obsArray) && hasOwnProperty(obsArray, PATCHED_KEY)) {\r\n        subscription = obsArray.subscribe(handler, null, eventFunc);\r\n      } else {\r\n        throw new Error(\"Can not subscribe to 'arrayChange' because dependency is not an 'observableArray'\");\r\n      }\r\n    } else {\r\n      const koComputed = ko.computed(dependencyOrEvent as () => any).extend({ notify: \"always\" });\r\n\r\n      subscription = koComputed.subscribe(handler, null, eventFunc);\r\n\r\n      const originalDispose = subscription.dispose;\r\n      // dispose hidden computed with subscription\r\n      subscription.dispose = function (this: ko.Subscription) {\r\n        originalDispose.call(this);\r\n        koComputed.dispose();\r\n      };\r\n    }\r\n    return subscription;\r\n  }\r\n}\r\n\r\n/*---------------------------------------------------------------------------*/\r\n\r\n/**\r\n * Get internal ko.observable() for object property decodated by @observable\r\n */\r\nexport function unwrap(instance: Object, key: string | symbol): any;\r\n/**\r\n * Get internal ko.observable() for object property decodated by @observable\r\n */\r\nexport function unwrap<T>(instance: Object, key: string | symbol): ko.Observable<T>;\r\n/**\r\n * Get internal ko.observable() for object property decodated by @observable\r\n */\r\nexport function unwrap(instance: Object, key: string | symbol) {\r\n  if (!hasOwnProperty(instance, key)) {\r\n    // invoke getter on instance.__proto__ that defines property on instance\r\n    // tslint:disable-next-line:no-unused-expression\r\n    instance[key];\r\n  }\r\n  return getOwnPropertyDescriptor(instance, key).get;\r\n}\r\n\r\n/*---------------------------------------------------------------------------*/\r\n/**\r\n * Mixin which add `subscribe()` instance method and implement `dispose()` method,\r\n * that disposes all subscription created by `subscribe()`\r\n */\r\nexport interface Disposable {\r\n  /** Dispose all subscriptions from this class */\r\n  dispose(): void;\r\n\r\n  /** Subscribe callback to `@observable` or `@computed` dependency changes or to some `@event` property */\r\n  subscribe<T>(\r\n    dependencyOrEvent: () => T,\r\n    callback: (value: T) => void,\r\n    options?: { once?: boolean, event?: \"change\" | \"beforeChange\" },\r\n  ): ko.Subscription;\r\n  /** Subscribe callback to `@observableArray` dependency \"arrayChange\" event */\r\n  subscribe<T>(\r\n    dependency: () => T[],\r\n    callback: (value: {\r\n      status: \"added\" | \"deleted\";\r\n      value: T;\r\n      index: number;\r\n    }[]) => void,\r\n    options: { once?: boolean, event: \"arrayChange\" },\r\n  ): ko.Subscription;\r\n  /** Subscribe callback to some `@event` property */\r\n  subscribe<T>(\r\n    event: (arg: T) => void,\r\n    callback: (arg: T) => void,\r\n    options?: { once?: boolean },\r\n  ): ko.Subscription;\r\n  /** Subscribe callback to some `@event` property */\r\n  subscribe<T1, T2>(\r\n    event: (arg1: T1, arg2: T2) => void,\r\n    callback: (arg1: T1, arg2: T2) => void,\r\n    options?: { once?: boolean },\r\n  ): ko.Subscription;\r\n  /** Subscribe callback to some `@event` property */\r\n  subscribe<T1, T2, T3>(\r\n    event: (arg1: T1, arg2: T2, arg3: T3, ...args: any[]) => void,\r\n    callback: (arg1: T1, arg2: T2, arg3: T3, ...args: any[]) => void,\r\n    options?: { once?: boolean },\r\n  ): ko.Subscription;\r\n\r\n  /** Get internal ko.observable() for class property decodated by `@observable` */\r\n  unwrap(key: string | symbol): any;\r\n  /** Get internal ko.observable() for class property decodated by `@observable` */\r\n  unwrap<T>(key: string | symbol): ko.Observable<T>;\r\n}\r\n\r\n/**\r\n * Mixin which add `subscribe()` instance method and implement `dispose()` method,\r\n * that disposes all subscription created by `subscribe()`\r\n */\r\nexport function Disposable(): new () => Disposable;\r\n/**\r\n * Mixin which add `subscribe()` instance method and implement `dispose()` method,\r\n * that disposes all subscription created by `subscribe()`\r\n * @param Base {Function} Base class to extend\r\n */\r\nexport function Disposable<T extends Function>(\r\n  // tslint:disable-next-line:variable-name\r\n  Base: T,\r\n): (new (...args: any[]) => Disposable) & T;\r\n/**\r\n * Mixin which add `subscribe()` instance method and implement `dispose()` method,\r\n * that disposes all subscription created by `subscribe()`\r\n * @param Base {Function} Base class to extend\r\n */\r\nexport function Disposable<T extends new (...args: any[]) => any>(\r\n  // tslint:disable-next-line:variable-name\r\n  Base?: T,\r\n) {\r\n  if (typeof Base === \"undefined\") {\r\n    Base = class { } as T;\r\n  }\r\n  return class extends Base {\r\n    /** Dispose all subscriptions from this class */\r\n    dispose() {\r\n      const subscriptions: ko.Subscription[] = this[SUBSCRIPTIONS_KEY as any];\r\n      if (subscriptions) {\r\n        subscriptions.forEach((subscription) => {\r\n          subscription.dispose();\r\n        });\r\n        delete this[SUBSCRIPTIONS_KEY as any];\r\n      }\r\n    }\r\n\r\n    /** Subscribe callback to `@observable` or `@computed` dependency changes or to some `@event` */\r\n    subscribe() {\r\n      const subscription: ko.Subscription = subscribe.apply(null, arguments);\r\n      const subscriptions: ko.Subscription[] = this[SUBSCRIPTIONS_KEY as any] ||\r\n        (this[SUBSCRIPTIONS_KEY as any] = []);\r\n      subscriptions.push(subscription);\r\n      return subscription;\r\n    }\r\n\r\n    /** Get internal ko.observable() for class property decodated by `@observable` */\r\n    unwrap(key: string) {\r\n      return unwrap(this, key);\r\n    }\r\n  };\r\n}\r\n","/**\r\n * Copyright (c) 2016-2018 Dmitry Panyushkin\r\n * Available under MIT license\r\n */\r\nimport * as ko from \"knockout\";\r\nimport { arraySlice, defineProperty } from \"./common-functions\";\r\nimport { EventType } from \"./knockout-decorators\";\r\n\r\nexport function defineEventProperty(instance: Object, key: string | symbol) {\r\n  const subscribable = new ko.subscribable<any[]>();\r\n\r\n  const event: EventType = function () {\r\n    const eventArgs = arraySlice(arguments);\r\n    subscribable.notifySubscribers(eventArgs);\r\n  } as any;\r\n\r\n  event.subscribe = function (callback: Function) {\r\n    return subscribable.subscribe(function (eventArgs: any[]) {\r\n      callback.apply(null, eventArgs);\r\n    });\r\n  };\r\n\r\n  defineProperty(instance, key, {\r\n    value: event,\r\n  });\r\n\r\n  return event;\r\n}\r\n"],"names":["prefix","PATCHED_KEY","EXTENDERS_KEY","SUBSCRIPTIONS_KEY","Symbol","ArrayPrototype","Array","prototype","defineProperty","instance","key","descriptor","configurable","Object","extendObject","ko.utils","extend","objectForEach","isArray","bind","getPrototypeOf","getOwnPropertyDescriptor","hasOwnProperty","Function","call","arraySlice","slice","applyExtenders","target","dictionary","extenders","forEach","extender","koExtender","defineObservableProperty","value","deep","expose","observable","ko.observable","setter","newValue","prepareDeepValue","enumerable","get","set","String","prepareDeepObject","constructor","defineObservableArray","observableArrayOption","deepObservableOption","exposeObservableOption","computedDecoratorOptions","deepArrayMethods","allArrayMethods","deepObservableArrayMethods","allObservableArrayMethods","allMethods","obsArray","ko.observableArray","insideObsArray","array","lastValue","peek","fnName","i","length","apply","arguments","result","push","args","unshift","splice","oldItem","newItem","replace","mutator","nativeArray","valueWillMutate","valueHasMutated","index","observableDecorator","propKey","Error","this","computedDecorator","desc","options","_a","koComputed","ko.computed","subscribe","dependencyOrEvent","callback","once","eventFunc","subscription_1","dispose","event","subscription_2","handler","koComputed_1","notify","originalDispose_1","unwrap","Base","tslib_1.__extends","class_2","subscriptions","subscription","bound","name","template","styles","ko.components","register","viewModel","createViewModel","params","element","templateNodes","synchronous","prototypeOrOptinos","propDesc","pure","subscribable","ko.subscribable","eventArgs","notifySubscribers","defineEventProperty","extendersOrFactory","existingKey","defineExtenders","prototypeOrOptions"],"mappings":"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"}